<link rel="stylesheet" href="style.css">
<meta name="viewport" content="width=500">
<meta charset="UTF-8">

<header>Curtis Autery, pretty ok husband, dad, and software writer.</header>

<nav>
  <a href="/">blog</a>
  <a href="/projects">projects</a>
  <a href="/about">about</a>
</nav>

<article>
<h1 id="outsiders-tdd-and-the-area-of-a-polygon">Outsiders, TDD, and the area of a polygon</h1>
<p>In the closing years of the 18th century, Sarah Green, the wife of Nottingham baker George Green, gave birth to a son, also named George, who would shake up the world, but never know.</p>
<p>When George was a young boy, his father noticed he was good with numbers, and so sent him off to an expensive private school. He returned after only one year, for reasons that aren&#39;t recorded. His father also owned a mill, and when George was old enough to apprentice there, he fell in love with the mill manager&#39;s daughter. Later they married, and together raised a family of seven children. In total, George would work at his father&#39;s mill for 20 years. Surprisingly, this is the background of one of the most influential mathematicians of all time.</p>
<p>As an adult, George was wealthy enough to join a local &quot;subscription library&quot;, a club for gentlemen, under the encouragement of his property-owning cousin who was a member. George was not a typical club member since he worked with his hands, but his reputation as an amateur mathematician was enough to cross class lines.</p>
<p>After five years in the club, he self-published a paper titled <a href="https://books.google.com/books/download/An_Essay_on_the_Application_of_Mathemati.pdf?id=GwYXAAAAYAAJ&amp;output=pdf">&quot;An Essay on the Application of Mathematical Analysis to the Theories of Electricity and Magnetism&quot;</a>, which contains 90 pages of tables of observations, equations, and lengthy explanations on his experiments with electricity. In the paper, he does two very remarkable things. First, he invents the theory of potential, which is now used in everything from Riemannian geometry, to Markov chains, to Fourier transforms.</p>
<p>Second, he extended the fundamental theorem of calculus by building on the &quot;area under a curve&quot; formulae, coming up with a method to calculate the area of a closed curve given only the functions that describe its border. After Green&#39;s death, the significance of this became known to the scientific community, and now Green&#39;s Theorem is one of the four fundamental theorems of vector calculus.</p>
<p>Later in life, Green joined a Cambridge school as an undergraduate, and wrote a handful of papers on wave theory and hydrodynamics. In his late 40s, he grew ill, and returned home, succumbing to his illness shy of his 48th birthday. His work inspired the &quot;Cambridge school&quot; of natural philosophers that became legends - James Clerk Maxwell (of Maxwell&#39;s Demon fame), Lord Kelvin, and George Stokes (polarization and optics), just to name a few. Each of his mathematical successors is deserving of all the accolades they received in life, but they all built on the insights of a man almost lost to history, buried in an unassuming family plot in the church across from his mill.</p>
<p>George&#39;s story resonates with me in a deeply personal way. In my life of writing software, I have done nothing nearly as extraordinary as change how calculus is taught worldwide, but I have been the guy who was the outlier in a room full of gentlemen, and I understand the joy in exploring hard topics because they&#39;re interesting, not because they are part of your formal training.</p>
<p>What sparked all this interest in a mathematician I hadn&#39;t heard of before? It all started with an interesting coding challenge.</p>
<h2 id="the-challenge">The Challenge</h2>
<p>The challenge was this: Given directions to draw an L-shaped room, calculate its area. The input was an array of vectors, each vector being a direction and a length, as if driving around the circumference of a room. Here is a sample input:</p>
<pre><code>[&quot;(N,9)&quot;, &quot;(E,16)&quot;, &quot;(S, 4)&quot;, &quot;(W,7)&quot;, &quot;(S,5)&quot;, &quot;(W,9)&quot;]</code></pre>
<p>It describes an L-shaped room that looks like this:</p>
<p><img src="/images/ra-room.png" alt=""></p>
<p>Visually inspecting the shape, it&#39;s easy for a human to understand that this is a 16x9 rectangle with a 7x5 rectangle cut out of it, making the room area 144 - 35 = 109 square units. When first faced with the puzzle, my spur of the moment solution attempt was to note which vector directions repeated, and which didn&#39;t. Two of the vector directions don&#39;t repeat, so their values are the base rectangle, and the rectangle to be subtracted is described by the first direction to repeat&#39;s second value, and the second direction to repeat&#39;s first value. Yes... that&#39;s quite a hacky approach to the problem. Maybe that works in all L-room cases and maybe it doesn&#39;t, but it is definitely not a general solution that works with other room shapes.</p>
<p>I was unsatisfied with my approach, so the next day I googled &quot;polygon area given corner coordinates&quot; or something like that, and quickly found the <a href="https://en.wikipedia.org/wiki/Shoelace_formula">Shoelace Formula</a>, which solves this for any arbitrary, non-intersecting polygon. It was a rabbit hole that led me to George, several calculus textbooks, and descriptive videos by math professors.</p>
<p>I dove in, and along the way also went back to the basics with using <a href="https://en.wikipedia.org/wiki/Test-driven_development">test-driven development</a> (TDD) to quickly create some simple projects, starting at &quot;bundle init&quot;, and writing a failing spec. The math research and coding practice combined to be the software writing equivalent of Rocky falling to Clubber Lang, then deciding to listen to some bad 80s rock at the gym while he gets himself back into fighting shape. In the end I got myself excited about numbers and coding again, and it was all time well spent.</p>
<h2 id="the-shoelace-formula">The Shoelace Formula</h2>
<p>The shoelace formula makes finding the area of polygons straightforward and elegant, but it&#39;s not immediately obvious why it works. Collect all the coordinates going counter-clockwise around the perimeter, and include the first point again at the end. Assume point Pn has coordinates (xn, yn), e.g., point P1 has coords (x1, y1). The formula for finding the polygon&#39;s area is then:</p>
<p><span class="math"><span class="fraction"><span class="numerator">1</span>2</span> ( (洧논1洧녽2 - 洧논2洧녽1) + (洧논2洧녽3 - 洧논3洧녽2) ... + (洧논洧녵洧녽1 - 洧논1洧녽洧녵) )</span></p>
<p>To understand why this works, let&#39;s take a step back...</p>
<p>Given any two points that produce a triangle with the origin, moving counterclockwise with respect to the origin, let&#39;s call the points (a, b) and (c, d), the area of the parallelogram (0, 0), (a, b), (a+c, b+d), (c, d) can be calculated by ad - bc. The best visual for understanding why that formula works is probably Solomon Golomb&#39;s famous &quot;proof without words&quot;:</p>
<p><img src="/images/proof-without-words.png" alt=""></p>
<p>We can deduce the same formula algebraically with a little elbow grease. To find the area of the parallelogram below...</p>
<p><img src="/images/ra-parallelogram.png" alt=""></p>
<p>We can draw a bounding box around it, and divide the area outside the parallelogram into congruent shapes we can build rectangles with:</p>
<p><img src="/images/ra-bounding-box.png" alt=""></p>
<p><img src="/images/ra-rectangle1.png" alt="">
<img src="/images/ra-rectangle2.png" alt=""></p>
<p>The rectangles will have the areas <code>cd</code> and <code>b(a+2c)</code>. So, the area of the parallelogram is the area of the bounding box <code>(a+c)(b+d)</code>, minus the rectangles:</p>
<pre><code>area = (a+c)(b+d) - cd - b(a+2c)
     = ab + ad + bc + cd - cd - (ab + 2bc)
     = ab + ad + bc + cd - cd - ab - 2bc
     = ab + ad + bc - ab - 2bc
     = ad + bc - 2bc
     = ad - bc</code></pre>
<p>Dividing that in half gives us the area of triangle (0, 0), (a, b), (c, d).</p>
<p>Breaking any arbitrary polygon (so long as none of the lines cross) up into triangles with respect to origin, can be used to calculate the shape&#39;s total area with this method. Take our original L-shaped room. If we assume the bottom left corner sits on origin, then that saves us a pair of calculations. Going counter-clockwise around the shape, form a triangle from the first pair of points to origin:</p>
<p><img src="/images/ra-step1.png" alt=""></p>
<p>I&#39;ll keep a running total of parallelogram areas, and divide everything in half at the end. Using the shoelace method, our first area is <span class="math">(9칑5) - (9칑0)</span> or 45, representing double the shaded area.</p>
<p>The next triangle is where things get weird:</p>
<p><img src="/images/ra-step2.png" alt=""></p>
<p>Our &quot;sweep&quot; has just moved clockwise, so it should produce a negative area. It looks to be subtracting part of the triangle we just considered, and some random wedge outside the shape. Let&#39;s pretend that&#39;s not as insane as it sounds, and continue. The formula gives us <span class="math">(9칑5) - (16칑5),</span> or <code>45 - 80</code>, or -35. This makes our running total</p>
<pre><code>45 - 35 = 10</code></pre>
<p>The next triangle shows that we&#39;re still on the right track:</p>
<p><img src="/images/ra-step3.png" alt=""></p>
<p>We&#39;ve added back in both of the shapes subtracted in the previous step, along with the small triangle in the upper-right. Using the formula, we have <span class="math">(16칑9) - (16칑5)</span>, or <code>144 - 80</code>, or 64. Our running total is now</p>
<pre><code>45 - 35 + 64 = 74</code></pre>
<p>This brings us to the last triangle we have to consider:</p>
<p><img src="/images/ra-step4.png" alt=""></p>
<p>The formula gives us <span class="math">(16 칑 9) - (9 칑 0)</span>, or 144, making our final running total</p>
<pre><code>45 - 35 + 64 + 144 = 218</code></pre>
<p>Dividing that in half gives us the area we calculated initially, 109.</p>
<p>If this still isn&#39;t intuitive, the most approachable explanation I&#39;ve found for why this works is in <a href="https://www.youtube.com/watch?v=0KjG8Pg6LGk">this Mathologer video</a> from Burkard Polster, math professor at Monash University.</p>
<p>Going the other direction, <a href="https://www.youtube.com/watch?v=Bh0pSVByxbo">this video</a> by Wichita State University&#39;s Justin Ryan shows how to turn Green&#39;s theorem into the shoelace formula.</p>
<p>Lots of fun. I emplore you to dig in. I also highly recommend <a href="https://www.whitman.edu/mathematics/calculus_online/">Calculus: early transcendentals</a> from Whitman College as a calculus refresher, if that&#39;s your jam.</p>
<h2 id="coding-up-a-solution">Coding up a solution</h2>
<p>Starting with a fresh ruby project, I&#39;m going to TDD my original code challenge, and end up with a small program that parses the array of vectors input, tokenizes it, turns it into coordinates, and applies the shoelace formula.</p>
<p>This work is being done from a <a href="https://tidbits.com/2019/12/08/resources-for-adapting-to-zsh-in-catalina/">shell</a> on a pre-M1 <a href="https://en.wikipedia.org/wiki/MacBook_Pro">Macbook</a>, using <a href="https://rubyreferences.github.io/rubychanges/2.7.html">ruby 2.7</a>, with some standard gems, namely <a href="https://rspec.info/">rspec</a>, <a href="https://bundler.io/">bundler</a>, and <a href="http://pry.github.io/">pry</a>, with <a href="https://stackoverflow.blog/2017/05/23/stack-overflow-helping-one-million-developers-exit-vim/">vim</a> as an editor. To begin, let&#39;s make a folder for the project (which I&#39;ll just call &quot;area&quot;), use bundler to initialize a Gemfile, add rspec to it so we can test as we go, and bind gems to the project:</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro dev %</strong> <em>mkdir area &amp;&amp; cd area</em>
<strong>curtis@Curtis-Autery-MBPro area %</strong> <em>bundle init</em>
Writing new Gemfile to /Users/curtis/dev/area/Gemfile
<strong>curtis@Curtis-Autery-MBPro area %</strong> <em>echo &#39;gem &quot;rspec&quot;&#39; &gt;&gt; Gemfile</em>
<strong>curtis@Curtis-Autery-MBPro area %</strong> <em>bundle</em>
Fetching gem metadata from https://rubygems.org/...
Resolving dependencies...
Using bundler 2.1.4
Using diff-lcs 1.4.4
Using rspec-support 3.10.3
Using rspec-core 3.10.1
Using rspec-expectations 3.10.1
Using rspec-mocks 3.10.2
Using rspec 3.10.0
Bundle complete! 1 Gemfile dependency, 7 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
<strong>curtis@Curtis-Autery-MBPro area %</strong></code></pre>
<p>Our sample input:</p>
<pre><code>[&quot;(N,9)&quot;, &quot;(E,16)&quot;, &quot;(S, 4)&quot;, &quot;(W,7)&quot;, &quot;(S,5)&quot;, &quot;(W,9)&quot;]</code></pre>
<p>...is in a format called <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, which is ubiquitous in modern sotware writing. I&#39;m going to put my sample input into a file, then open a pry <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> (TODO: improve that Wikipedia page), then read the file into a JSON parser.</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>echo &#39;[&quot;(N,9)&quot;, &quot;(E,16)&quot;, &quot;(S, 4)&quot;, &quot;(W,7)&quot;, &quot;(S,5)&quot;, &quot;(W,9)&quot;]&#39; &gt; input.txt</em>
<strong>curtis@Curtis-Autery-MBPro area %</strong> <em>pry</em>
<strong>[1] pry(main)&gt;</strong> <em>input = File.read(&#39;input.txt&#39;)</em>
=&gt; &quot;[\&quot;(N,9)\&quot;, \&quot;(E,16)\&quot;, \&quot;(S, 4)\&quot;, \&quot;(W,7)\&quot;, \&quot;(S,5)\&quot;, \&quot;(W,9)\&quot;]\n&quot;
<strong>[2] pry(main)&gt;</strong> <em>require &#39;json&#39;</em>
=&gt; true
<strong>[3] pry(main)&gt;</strong> <em>parsed = JSON.parse(input)</em>
=&gt; [&quot;(N,9)&quot;, &quot;(E,16)&quot;, &quot;(S, 4)&quot;, &quot;(W,7)&quot;, &quot;(S,5)&quot;, &quot;(W,9)&quot;]
<strong>[4] pry(main)&gt;</strong> <em>parsed[2]</em>
=&gt; &quot;(S, 4)&quot;</code></pre>
<p>At this point <code>parsed</code> is a ruby array that I can iterate over, but each element needs more processing to turn that into a vector with a direction string and a distance integer. If this were part of a larger project, or if we needed to account for possible errors in the input, I&#39;d continue down this route and write some cumbersome parsing code. Fortunately, the challenge declared that you could assume both correct input data (with the caveat that sometimes there&#39;s a pesky space in a vector), and that the described shape would always be a complete polygon. With that in mind, we can afford to be a little more bold and ditch JSON parsing altogether, and just look for word tokens.</p>
<pre class="codez"><code><strong>[5] pry(main)&gt;</strong> <em>tokens = input.scan /\w+/</em>
=&gt; [&quot;N&quot;, &quot;9&quot;, &quot;E&quot;, &quot;16&quot;, &quot;S&quot;, &quot;4&quot;, &quot;W&quot;, &quot;7&quot;, &quot;S&quot;, &quot;5&quot;, &quot;W&quot;, &quot;9&quot;]</code></pre>
<p>The <code>\w+</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">regular expression</a> that asks for one or more &quot;word&quot; characters. The definition of a word character changes over time and between programming languages, but it is generally letters, numbers, and the underscore. The ruby <code>scan</code> method runs a regular expression repeatedly on a string, and collects all the matches into an array.</p>
<p>This gets us most of the way to turning our input file into something usable. The last things we need to do are collect the tokens in pairs (ruby has good combinatorics methods to help with things like this), and to turn the distance strings into ruby numbers.</p>
<pre class="codez"><code>[6] <strong>pry(main)&gt;</strong> <em>tokens.each_slice(2).map { |dir, len| [dir, len.to_i] }</em>
=&gt; [[&quot;N&quot;, 9], [&quot;E&quot;, 16], [&quot;S&quot;, 4], [&quot;W&quot;, 7], [&quot;S&quot;, 5], [&quot;W&quot;, 9]]</code></pre>
<p>And that&#39;s about all we need our pry REPL for. We know how we&#39;re going to read in the file and turn it into usable chunks. The rest of what we need to is turn an array of vectors into an array of coordinates, and to run the shoelace formula over those coordinates to return the polygon&#39;s area. All of that can be easily written with TDD: Write a test for something you want the program to do, make sure the test fails, then write app code to make the test succeed.</p>
<p>It took me a very long time in my software writing career before I understood the value of that process. I&#39;ve been required to write passing tests for all my code for the last four years, but for most of that time I used it just to check core pieces of app code that I&#39;d already written. TDD, on the other hand, lets you document the system you want to write, and makes you think about the problem you want to solve in smaller pieces that can be tested independently.</p>
<p>The two basic items we want to test are turning vectors into coordinates, and calculating an area. Starting with the first, let&#39;s create a class called <code>coord_maker</code>, and a corresponding spec:</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>touch coord_maker.rb coord_maker_spec.rb</em>
<strong>curtis@Curtis-Autery-MBPro area %</strong> <em>ls</em>
Gemfile         Gemfile.lock        coord_maker.rb      coord_maker_spec.rb input.txt</code></pre>
<p>In coord_maker_spec.rb I&#39;ll start by simply importing the nonexistent CoordMaker class and calling RSpec.describe to instantiate it:</p>
<pre class="codez"><code># coord_maker_spec.rb
require &#39;rspec&#39;
require_relative &#39;coord_maker&#39;

RSpec.describe CoordMaker do
end</code></pre>
<p>Running the spec shows the expected error that the class doesn&#39;t exit:</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>rspec coord_maker_spec.rb</em>

An error occurred while loading ./coord_maker_spec.rb.
Failure/Error:
  RSpec.describe CoordMaker do
  end

NameError:
  uninitialized constant CoordMaker
# ./coord_maker_spec.rb:4:in `&lt;top (required)&gt;&#39;
No examples found.


Finished in 0.00002 seconds (files took 0.11449 seconds to load)
0 examples, 0 failures, 1 error occurred outside of examples</code></pre>
<p>...which stubbing out the class will correct:</p>
<pre class="codez"><code># coord_maker.rb
class CoordMaker

end</code></pre>
<p>curtis@Curtis-Autery-MBPro area % rspec coord_maker_spec.rb
No examples found.</p>
<p>Finished in 0.00021 seconds (files took 0.11907 seconds to load)
0 examples, 0 failures</p>
<p>From here I&#39;ll show just the code deltas and errors, and at the end I&#39;ll link to a GitHub repo for this project. In the project, each commit happens after a new spec passes.</p>
<p>We want a CoordMaker instance to initialize with a list of vectors and turn them into coordinates. The simplest example of that would be taking a single vector, let&#39;s say <code>[&quot;N&quot;, 4]</code>, and returning origin and <code>(0, 4)</code>. In coord_maker_spec, let&#39;s check for that.</p>
<pre class="codez"><code>RSpec.describe CoordMaker do
  subject { CoordMaker.new(vectors) }

  context &#39;with a single vector&#39; do
    let(:vectors) { [[&#39;N&#39;, 4]] }

    it &#39;returns (0,0) and (0,4)&#39; do
      expect(subject.coords).to contain_exactly([0, 0], [0, 4])
    end
  end
end</code></pre>
<p>Which gives...</p>
<pre class="codez"><code>1) CoordMaker with a single vector returns (0,0) and (0,4)
   Failure/Error: subject { CoordMaker.new(vectors) }

   ArgumentError:
     wrong number of arguments (given 1, expected 0)</code></pre>
<p>This drives us to add an initializer to our class to accept a variable, and to return the expected array.</p>
<pre class="codez"><code>class CoordMaker
  attr_reader :coords

  def initialize(vectors)
    @coords = [[0, 0], [0, 4]]
  end
end</code></pre>
<p>Which gives...</p>
<pre class="codez"><code>curtis@Curtis-Autery-MBPro area % rspec coord_maker_spec.rb
.

Finished in 0.00432 seconds (files took 0.08343 seconds to load)
1 example, 0 failures</code></pre>
<p>Believe me, I hear you. My app code isn&#39;t calculating a damned thing, and giving it any other vectors will return the wrong results. I get it, and I used to balk at that, too. What we&#39;re checking now isn&#39;t that the coords are calculated, but that it returns an array of arrays, that the spec can parse them, and that the spec and class agree on variable/method names. Doing this step checks for stupid typos and misunderstanding variable types.</p>
<p>At this point, it would be fine to rewrite the app code to calculate coordinates and run the spec again, but the normal pattern is to write a new spec with different inputs first.</p>
<pre class="codez"><code>context &#39;with a square&#39; do
  let(:vectors) { [[&#39;N&#39;, 4], [&#39;E&#39;, 4], [&#39;S&#39;, 4], [&#39;W&#39;, 4]] }

  it &#39;coords describe a square and return to origin&#39; do
    expect(subject.coords).to contain_exactly([0, 0], [0, 4], [4, 4], [4, 0], [0, 0])
  end
end</code></pre>
<p>Which gives...</p>
<pre class="codez"><code>curtis@Curtis-Autery-MBPro area % rspec coord_maker_spec.rb
.F

Failures:

  1) CoordMaker with a square coords describe a square and return to origin
     Failure/Error: expect(subject.coords).to contain_exactly([0, 0], [0, 4], [4, 4], [4, 0], [0, 0])

       expected collection contained:  [[0, 0], [0, 0], [0, 4], [4, 0], [4, 4]]
       actual collection contained:    [[0, 0], [0, 4]]
       the missing elements were:      [[0, 0], [4, 0], [4, 4]]
     # ./coord_maker_spec.rb:19:in `block (3 levels) in &lt;top (required)&gt;&#39;

Finished in 0.02385 seconds (files took 0.08586 seconds to load)
2 examples, 1 failure</code></pre>
<p>Now let&#39;s write some code to calculate coordinates, and we have two waiting examples to make sure we&#39;re doing it right.</p>
<pre class="codez"><code>def initialize(vectors)
  x = 0
  y = 0
  @coords = [[x, y]]

  vectors.each do |direction, distance|
    case direction
    when &#39;N&#39;
      y += distance
    when &#39;S&#39;
      y -= distance
    when &#39;E&#39;
      x += distance
    when &#39;W&#39;
      x -= distance
    end

    coords.push([x, y])
  end
end</code></pre>
<p>Which gives...</p>
<pre class="codez"><code>..

Finished in 0.0045 seconds (files took 0.08336 seconds to load)
2 examples, 0 failures</code></pre>
<p>We can add additional checks, like vectors with some other distance than 4, or an L-shaped room, but I&#39;m satisfied with what we have since CoordMaker is a unitasker with simple code. Instead, let&#39;s move on in the same vein with a Room class and spec. Room takes an array of coordinates, and calculates an integer area (since we can only move in integer steps in the four primary directions, the area will always be a whole number).</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>touch room.rb room_spec.rb</em>
<strong>curtis@Curtis-Autery-MBPro area %</strong> <em>ls</em>
Gemfile         coord_maker.rb      input.txt       room_spec.rb
Gemfile.lock        coord_maker_spec.rb room.rb
<strong>curtis@Curtis-Autery-MBPro area %</strong></code></pre>
<p>I&#39;ll skip the incremental TDD steps (althought they&#39;re in the GitHub repo) and jump right to a correct rectangle area calculation using the shoestring formula.</p>
<p>The spec describes a 3x5 rectangle:</p>
<pre class="codez"><code>require &#39;rspec&#39;
require_relative &#39;room&#39;

RSpec.describe Room do
  subject { described_class.new(coords) }

  context &#39;with a rectangle&#39; do
    let(:coords) { [[0, 0], [0, 5], [3, 5], [3, 0], [0, 0]] }

    it &#39;calculates the correct area&#39; do
      expect(subject.area).to eq(15)
    end
  end
end</code></pre>
<p>...and the app code calculates area with the shoelace formula.</p>
<pre class="codez"><code>class Room
  attr_reader :area

  def initialize(coords)
    working = 0

    coords.each_cons(2) do |p1, p2|
      a, b = p1
      c, d = p2

      working += (a * d - b * c)
    end

    @area = working.abs / 2
  end
end</code></pre>
<p>Here I&#39;m using another wonderful Ruby combinatorics method, <code>each_cons</code>, which instead of splitting the array up in groups, takes them in sets, but only increments the index by 1. For example:</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>pry</em>
<strong>[1] pry(main)&gt;</strong> <em>(1..5).each_cons(2) { p _1 }</em>
[1, 2]
[2, 3]
[3, 4]
[4, 5]
=&gt; nil</code></pre>
<p>Also, since I have no way of knowing which direction the vectors drive around the shape, this returns the absolute value of the area, in case the path was clockwise overall.</p>
<p>Almost done. Let&#39;s add another spec to describe the example from the original coding challenge:</p>
<pre class="codez"><code>context &#39;with an L-shaped room&#39; do
  let(:coords) { [[0, 0], [0, 9], [16, 9], [16, 5], [9, 5], [9, 0], [0, 0]] }

  it &#39;calculates the correct area&#39; do
    expect(subject.area).to eq(109)
  end
end</code></pre>
<p>Which gives...</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>rspec room_spec.rb</em>
..

Finished in 0.00405 seconds (files took 0.08648 seconds to load)
2 examples, 0 failures</code></pre>
<p>The last bit, then is the main script that parses the input file, calls our classes, and prints the result. I&#39;ll call the file <code>calculate.rb</code>, and use the method from our first pry session. Since we have all the heavy lifting app code well-defined and tested, the script is surprisingly simple:</p>
<pre class="codez"><code>require_relative &#39;coord_maker&#39;
require_relative &#39;room&#39;

tokens = File.read(&#39;input.txt&#39;).scan /\w+/
vectors = tokens.each_slice(2).map { |direction, distance| [direction, distance.to_i] }

coord_maker = CoordMaker.new(vectors)
room = Room.new(coord_maker.coords)

puts &quot;Room area: #{room.area}&quot;</code></pre>
<p>And running that produces the answer we expect:</p>
<pre class="codez"><code><strong>curtis@Curtis-Autery-MBPro area %</strong> <em>ruby calculate.rb</em>
Room area: 109</code></pre>
<p>If you&#39;d like to see each TDD step as individual commits, a repo is available at <a href="https://github.com/ceautery/code_challenge-room_area">https://github.com/ceautery/code_challenge-room_area</a>.</p>

</article>
<script src="script.js"></script>

