<!DOCTYPE html>
<html lang="en">
<head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app202.us.archive.org';v.server_ms=793;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="/_static/js/playback.bundle.js?v=BsQ6byDz" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=cRqOKCOw" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://curtisautery.appspot.com/5898536285634560","20170702094731","https://web.archive.org/","web","/_static/",
	      "1498988851");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=NHuXCfBH" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

	<meta charset="utf-8">
	
		
		<title>Bare-bones WebGL and the math behind 3D graphics</title>
		<meta name="description" content="An introduction to WebGL for JavaScript programmers with no 3D graphics background, with emphasis on the math, and no use of external libraries">
	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="author" content="Curtis Autery">

	<link href="/web/20170702094731cs_/http://curtisautery.appspot.com/static/bootstrap/css/bootstrap.min.css" rel="stylesheet">

	<style type="text/css">
		#cover {
			background-size: 100% auto;
			background-image: url(/web/20170702094731im_/http://curtisautery.appspot.com/static/cover.jpg);
			border-radius: 6px;
			margin-top: -20px;
		}

		#cover h1 {
			color: #fff;
			background: rgba(0, 0, 0, 0.4);
			line-height: 1.5;
			font-size: 2em;
		}

		@media screen and (min-width: 768px) {
			#cover h1 {
			    font-size: 63px;
			}

			#body {
				text-align: justify;
			}
		}

		hr {
			border-top: 1px solid gray;
		}

		img {
			margin-bottom: 5px;
		}
	</style>

	<script type="text/javascript">
		function populate_entries( entries ) {
			$( '#entries' ).empty();
			for ( var e in entries ) add_entry( entries[e].Title, entries[e].ID );
		}

		function add_entry( title, key ) {
			var html = '<li><a href="/' + key + '">' + title + '</a></li>';
			$( '#entries' ).append( html );
		}

		function init() {
			if (document.location.pathname == "/1") $('#About').addClass("active");
			if (document.location.pathname == "/") {
				$('#Home').addClass("active");
				$('#latest').empty();
			} else {
				$.ajax({
					url: '/list',
					type: 'GET',
					success: function( results ) {
						populate_entries( $.parseJSON( results ) );
					},
					error: function( xhr, ajaxOptions, thrownError ) {
						console.log( xhr );
						console.log( ajaxOptions );
						alert( thrownError );
					}
				});
			}
		}
	</script>
</head>
<body onload="init()"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display:none;direction:ltr;">
<div id="wm-ipp" style="position:fixed;left:0;top:0;right:0;">
<div id="wm-ipp-inside">
  <div style="position:relative;">
    <div id="wm-logo" style="float:left;width:110px;padding-top:12px;">
      <a href="/web/" title="Wayback Machine home page"><img src="/_static/images/toolbar/wayback-toolbar-logo-200.png" srcset="/_static/images/toolbar/wayback-toolbar-logo-100.png, /_static/images/toolbar/wayback-toolbar-logo-150.png 1.5x, /_static/images/toolbar/wayback-toolbar-logo-200.png 2x" alt="Wayback Machine" style="width:100px" border="0" /></a>
    </div>
    <div class="r" style="float:right;">
      <div id="wm-btns" style="text-align:right;height:25px;">
                  <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a id="wm-save-snapshot-open" href="#"
	     title="Share via My Web Archive" >
            <span class="iconochive-web"></span>
          </a>
          <a href="https://archive.org/account/login.php"
             title="Sign In"
             id="wm-sign-in"
          >
            <span class="iconochive-person"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web"></span>
        	<a href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
	<a id="wm-tb-close" href="#close" onclick="__wm.h(event);return false;" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share">
          <a href="/web/20170702094731/http://web.archive.org/screenshot/http://curtisautery.appspot.com/5898536285634560"
             id="wm-screenshot"
             title="screenshot">
            <span class="wm-icon-screen-shot"></span>
          </a>
	<a id="wm-share-facebook" href="#" data-url="https://web.archive.org/web/20170702094731/http://curtisautery.appspot.com/5898536285634560" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
	<a id="wm-share-twitter" href="#" data-url="https://web.archive.org/web/20170702094731/http://curtisautery.appspot.com/5898536285634560" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
    </div>
    <table class="c" style="">
      <tbody>
	<tr>
	  <td class="u" colspan="2">
	    <form target="_top" method="get" action="/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://curtisautery.appspot.com/5898536285634560" onfocus="this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20170702094731" /><input type="submit" value="Go" /></form>
	  </td>
	  <td class="n" rowspan="2" style="width:110px;">
	    <table>
	      <tbody>
		<!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
		<tr class="m">
		  <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20161018140410/http://curtisautery.appspot.com/5898536285634560" title="18 Oct 2016"><strong>Oct</strong></a></td>
		  <td class="c" id="displayMonthEl" title="You are here: 09:47:31 Jul 02, 2017">JUL</td>
		  <td class="f" nowrap="nowrap">Aug</td>
		</tr>
		<!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
		<tr class="d">
		  <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20161018140410/http://curtisautery.appspot.com/5898536285634560" title="14:04:10 Oct 18, 2016"><img src="/_static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a></td>
		  <td class="c" id="displayDayEl" style="width:34px;font-size:24px;white-space:nowrap;" title="You are here: 09:47:31 Jul 02, 2017">02</td>
		  <td class="f" nowrap="nowrap"><img src="/_static/images/toolbar/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0" /></td>
		</tr>
		<!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
		<tr class="y">
		  <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20160503221127/http://curtisautery.appspot.com:80/5898536285634560" title="03 May 2016"><strong>2016</strong></a></td>
		  <td class="c" id="displayYearEl" title="You are here: 09:47:31 Jul 02, 2017">2017</td>
		  <td class="f" nowrap="nowrap">2018</td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td class="s">
	    	    <div id="wm-nav-captures">
	      	      <a class="t" href="/web/20170702094731*/http://curtisautery.appspot.com/5898536285634560" title="See a list of every capture for this URL">6 captures</a>
	      <div class="r" title="Timespan for captures of this URL">17 Nov 2014 - 02 Jul 2017</div>
	      </div>
	  </td>
	  <td class="k">
	    <a href="" id="wm-graph-anchor">
	      <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
		<canvas id="wm-sparkline-canvas" width="625" height="27" border="0"></canvas>
	      </div>
	    </a>
	  </td>
	</tr>
      </tbody>
    </table>
    <div style="position:absolute;bottom:0;right:2px;text-align:right;">
      <a id="wm-expand" class="wm-btn wm-closed" href="#expand" onclick="__wm.ex(event);return false;"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span style="font-size:80%">About this capture</span></a>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
                    <div id="wm-capinfo-collected-by">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
            <div style="display:inline-block;vertical-align:top;width:50%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/webwidecrawl);"></span>
		Organization: <a style="color:#33f;" href="https://archive.org/details/webwidecrawl" target="_new"><span class="wm-title">Internet Archive</span></a>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  The Internet Archive discovers and captures web pages through many different web crawls.

At any given time several distinct crawls are running, some for months, and some every day or longer.

View the web archive through the <a href="http://archive.org/web/web.php">Wayback Machine</a>.
	</div>
	      </div>
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/survey_00005)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/survey_00005" target="_new"><span class="wm-title">Survey Crawl Number 5: Oct 21st, 2016 to Sep 10th, 2017</span></a></div>
		<div style="max-height:75px;overflow:hidden;position:relative;">
	  <div style="position:absolute;top:0;left:0;width:100%;height:75px;background:linear-gradient(to bottom,rgba(255,255,255,0) 0%,rgba(255,255,255,0) 90%,rgba(255,255,255,255) 100%);"></div>
	  <p>The seed for this crawl was a list of every host in the Wayback Machine</p>

<p>This crawl was run at a level 1 (URLs including their embeds, plus the URLs of all outbound links including their embeds)</p>

<p>The WARC files associated with this crawl are not currently available to the general public.</p>
	</div>
	      </div>
    </div>
    </div>
    <div id="wm-capinfo-timestamps">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img src="/_static/images/loading.gif" alt="loading" /></div>
    </div>
    </div>
  </div></div></div></div><div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="https://archive.org/includes/donate.php?as_page=1&amp;transpiled=0&amp;referer=https%3A//web.archive.org/web/20170702094731/http%3A//curtisautery.appspot.com/5898536285634560"
	    scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><script type="text/javascript">
__wm.bt(625,27,25,2,"web","http://curtisautery.appspot.com/5898536285634560","20170702094731",1996,"/_static/",["/_static/css/banner-styles.css?v=NHuXCfBH","/_static/css/iconochive.css?v=qtvMKcIJ"]);
  __wm.rw(1);
</script>
<!-- END WAYBACK TOOLBAR INSERT -->
	<div class="navbar navbar-inverse navbar-static-top">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>

			<div class="navbar-collapse collapse">
				<ul class="nav navbar-nav">
					<li id="Home"><a href="/web/20170702094731/http://curtisautery.appspot.com/">Home</a></li>
					<li id="latest" class="dropdown">
						<a href="#" class="dropdown-toggle" data-toggle="dropdown">
							Latest
							<b class="caret"></b>
						</a>
						<ul id="entries" class="dropdown-menu">
							<li class="muted"><a href="javascript:blur()">loading...</a></li>
						</ul>
					</li>
				</ul>
				<ul class="nav navbar-nav navbar-right">
					<li id="About"><a href="/web/20170702094731/http://curtisautery.appspot.com/1">About</a></li>
					
				</ul>
			</div>
		</div>
	</div>

	<div class="container col-xs-12 col-md-8 col-md-offset-2">
		<div id="cover">
			<h1 class="text-center jumbotron">Stories for Outcasts</h1>
		</div>

		
			<h3 class="text-center">
				
					Bare-bones WebGL and the math behind 3D graphics
				
			</h3>
			<h4>Thursday, March 27, 2014</h4>
			<div id="body">
				<p>This introduction is designed for programmers who are wholly unfamiliar with WebGL and 3D graphics. It will take you through the basics of feeding vertex and color data to a WebGL buffer, the (surprisingly simple) math behind 4x4 translation matrices, and more complex topics like homogenous coordinates, orthographic versus perspective projections, Euler angles, gimbal lock, quaternions, and the like.</p>

<p>The official spec for the WebGL API can be found at <a href="https://web.archive.org/web/20170702094731/http://www.khronos.org/registry/webgl/specs/latest/1.0/">The khronos.org website</a>, and while it contains good information for the end programmer, particularly in the "non-normative" and example sections, it reads mainly like a guide for browser authors to implement the API itself, and is not an ideal starting point.</p>

<p>The net is also littered with tutorials for the budding WebGL programmer, but the ones I found initially had dependent third party libraries as an integral part, such as glMatrix, a good tool, but one that presumes a fair amount of familiarity with 3D rendering concepts. Use of external libraries in beginner-level tutorials I found muddied the waters, and it took me some effort to sort out the essential basics from the external libraries and design framework.</p>

<p>After I extracted the most basic path to draw some simple shapes, I decided to make that the basis for a comprehensive tutorial on WebGL concepts.</p>

<h2>Lesson 1: Draw simple shapes</h2>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson1.html">Lesson 1</a></p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7011/13437495754%5F41d2d67867.jpg" alt=""/></p>

<p>The above page is one of a set of 10 live demos of WebGL. It draws a triangle and square on a black background, similar to the first example on the learningwebgl.com site. The code is thoroughly commented, and if you're like me you'll dive right into it and come back here later. Have at it!</p>

<p>If you're back, or if you stayed, let's go over some of the basic concepts.</p>

<h3>What are the dimensions of the WebGL rendering area?</h3>

<p>2 by 2 by 2, in the range -1 through 1. If the final X, Y, or Z of a pixel falls outside of that range, it won't be displayed. The X and Y are scaled to the size of the canvas (viewport actually, there are some subtleties between the two when you resize the canvas which aren't important for getting started), with [0,0] being the center, and the directions being the same as standard Cartesian coordinates (e.g., Y increases as you move up, in contrast to Canvas 2D and most other computer rendering models where [0,0] is the upper-left corner and Y increases as you move down).</p>

<h3>What are we ultimately trying to do?</h3>

<p>Draw a three dimensional scene on a flat canvas.</p>

<p>It's important to keep this in mind, especially when you're first starting out and things don't appear to have the depth you expect them to. Depth is an illusion; we're only displaying things on a flat screen. The final Z of a pixel is, depending on what rendering mode you're in, either completely irrelevant, or used strictly for drawing order.</p>

<p>If you want to draw a scene with perspective (where a far away object is smaller and closer to the center of your field of view), or to rotate a scene on the X axis, say, towards you a little, so you can see the top and front in the same view, then you'll need to understand the maths behind translation matrices, which I'll get to below. Let's take some baby steps first.</p>

<h3>Create a WebGL context, set a background color.</h3>



<pre><code>var gl = canvas.getContext(&#39;webgl&#39;);
</code></pre>



<p>This is the official starting off point for rendering with WebGL. An HTML5 canvas element is queried with a context ID of "webgl", and returns a "rendering context", which transfers data between an OpenGL ES (embedded systems) engine and JavaScript. Early browser support for this was done under a different context ID, "experimental-webgl", leading to this common idiom today:</p>



<pre><code>var gl  = canvas.getContext(&#39;webgl&#39;) || canvas.getContext(&#39;experimental-webgl&#39;);
if (!gl) &#123; alert(&#34;WebGL not available&#34;); return; &#125;
</code></pre>



<p>Once your context has been created, it is ready to compile shaders, create buffers for JavaScript to feed vertex and color info to, etc. Before any real drawing happens, the simple step of clearing the canvas must take place. This happens in two steps:</p>



<pre><code>gl.clearColor(0, 0, 0, 1);
gl.clear(gl.COLOR&#95;BUFFER&#95;BIT);
</code></pre>



<p>Setting clearColor (the method takes 4 float variables between 0 and 1, representing red, green, blue, and alpha) can be done independently of all other functions, and maintains its state between draw calls (you can call clearColor once immediately after the WebGL context is created, and never again until you want to change the background color).</p>

<p>The second step, gl.clear(), is used for clearing the color, depth, and stencil buffers. It receives an integer composed of various constant values OR-ed together, depending on what exactly you're clearing. These include the values for COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, and STENCIL_BUFFER_BIT. What's going on behind the scenes when this is called is involved, but essentially the color buffer is initialized to what's in clearColor, and when the function containing clear() returns, a "compositing operation" is performed. If no draw operations happen between clear() being called and the containing function returning, then the canvas is cleared.</p>

<p>After a compositing operation is called (this is important), the <em>color buffer resets to transparent black</em>, ignoring the value stored in clearColor. This means that the next time a draw operation is called, the canvas area not covered by the draw operation will show the page body's background color. If, as in the lesson1 example above, the fragment shader (I'll talk about what that means shortly) doesn't set a color, then all the objects being rendered will also be in the page body's background color. All the draw operations will still happen, but the canvas will appear to be blank. To prevent this, call gl.clear() in the same function as the draw operation. There are alternatives to that, such as creating a WebGL context with the "preserveDrawingBuffer" attribute enabled, which has the ancillary effect of not clearing the cavas between draws. This can be handy, but in general, an explicit call to gl.clear() before draw operations is preferred.</p>

<p>If that doesn't make any sense, don't worry; just remember to always call clear before drawArrays or drawElements, and doing so in the same function call is safest.</p>

<h3>What are shaders?</h3>

<p>Good question. "Shader" is a term used differently by different sources. It can mean "something that uses light and color to indicate depth", or it can refer explicitly to a 3D graphics program meant to run on a GPU, with different sub-programs running at different rendering stages.</p>

<p>For the purpose of WebGL, there are two types of shaders: vertex and fragment. The vertex shader concerns itself with translating 3D locations to screen coordinates, applying translation matrices, and passing color variables to the fragment shader. The fragment shader (this is a gross simplification) is responsible for assigning color and depth order to each of an object's rasterized pixels (a fragment is, in essence, a pixel, but scaling and the differences between "canvas" and "viewport" mean fragments and pixels don't necessarily have a 1 to 1 relationship).</p>

<p>For the lesson1 page above, we have a vertex shader that does no translation, and we just feed it a handful of triangle vertices. The fragment shader, however, is empty, and will follow it's default behavior: rendering object pixels in transparent black. Here is the source code for those:</p>

<p><strong>Vertex shader</strong></p>



<pre><code>attribute vec2 vertexCoord;     /&#42; x and y coordinates of current vertex &#42;/
void main(void) &#123;
    /&#42; Set vertex position with above variable, at 0 depth, normal scale &#42;/
    gl&#95;Position = vec4(vertexCoord, 0, 1);
&#125;
</code></pre>



<p>The vertex shader above receives coordinates from JavaScript (from a buffer that JavaScript binds to, actually, but that's splitting hairs) in basic Cartesian X/Y coordinates, and tacks on a Z value of 0 so everything is on the same plane, and a <strong>W</strong> of 1, making a 4-element vector (vec4). What's W? The "homogeneous coordinate". I'll talk about what that means in the section on orthographic vs. perspective transformation.</p>

<p><strong>Fragment shader</strong></p>



<pre><code>void main(void)&#123; &#125;
</code></pre>



<p>Yep. The fragment shader in the first example does nothing. The pixel color will end up being transparent black, which means the HTML page background color will show. Where the vertex shader has a "gl_Position" variable to declare position, the fragment shader has a variable gl_FragColor, a vec4 of red, green, blue, and alpha floats, ranging from 0 to 1. If I wanted to explicitly set a color of opaque white for each object pixel, I could do this:</p>



<pre><code>void main(void)&#123;
    gl&#95;FragColor = vec4(1, 1, 1, 1);
&#125;
</code></pre>



<p>The later exercises will show how to do a little more with shaders, but nothing too far off from these basic concepts. A stumbling block to get over is that the shader source code isn't JavaScript, it's OpenGL ES. The source code needs to be compiled and linked by the WebGL context object, so the source code needs to be fed to the compiler as a string, and still be readable (i.e., multi-line).</p>

<p>Some developers get past this obstacle by declaring HTML script tags with a custom type so the JavaScript parser will ignore them (e.g. &lt;script type="x-shader/x-vertex"&gt;), and then pulling one line of that at a time from the DOM and concatenating it to a JavaScript string, and then passing that string to the compiler: Messy in small examples, but more sensible for larger programs. This method leads to being able to clearly lay out the shader source code as part of the HTML and not worry about escaping newlines and comments, but it gives the impression that your browser intrinsically knows what to do with it, which it doesn't. Yet.</p>

<p>Alternately, the source can be fed inline, as long as you properly escape any newlines or OpenGL comments. My lesson1 page above shows how to both of these correctly.</p>

<h3>Let's draw some stuff</h3>

<p>Before you completely lose interest, let's go over what's needed to draw a simple triangle. I recommend you go over the source code of the lesson1 example above, which has detailed comments. Let's assume we have the OpenGL ES shader source code above in the strings vert_source and frag_source, and that the WebGL context "gl" has already been created. Here, then, is everything needed to paint a simple triangle:</p>



<pre><code>v&#95;shader = gl.createShader(gl.VERTEX&#95;SHADER);
gl.shaderSource(v&#95;shader, vert&#95;source);
gl.compileShader(v&#95;shader);

f&#95;shader = gl.createShader(gl.FRAGMENT&#95;SHADER);
gl.shaderSource(f&#95;shader, frag&#95;source);
gl.compileShader(f&#95;shader);

shader = gl.createProgram();
gl.attachShader(shader, v&#95;shader);
gl.attachShader(shader, f&#95;shader);
gl.linkProgram(shader);
gl.useProgram(shader);

gl.bindBuffer(gl.ARRAY&#95;BUFFER, gl.createBuffer());
gl.bufferData(gl.ARRAY&#95;BUFFER, new Float32Array(&#91;
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
&#93;), gl.STATIC&#95;DRAW);

gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

gl.clearColor(0, 0, 0, 1);
gl.clear(gl.COLOR&#95;BUFFER&#95;BIT);
gl.drawArrays(gl.TRIANGLES, 0, 3);
</code></pre>



<p>Result: <img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7418/13437495224%5F4005c2f7f0%5Fo.png" alt=""/></p>

<p>So what just happened? In order, we:</p>

<ul>
<li>Created and compiled a vertex and fragment shader,</li>
<li>Created a WebGL program, attached and linked the shaders to it</li>
<li>Created a buffer and bound the gl context to it</li>
<li>Buffered an array of floats</li>
<li>Enabled the first "attribute" variable in the vertex shader</li>
<li>Described where in the buffered data the vertexCoord attribute could find its data</li>
<li>Set the clear color and cleared the viewport</li>
<li>And finally, drew the scene by reading 3 vertex points and rendering them as a triangle.</li>
</ul>

<p>If you're familiar with the 2D HTML5 canvas API, you'll see that this is substantially more complicated. I couldn't agree more. If you just want to render a simple 2D scene, WebGL is definitely not the way to go. It's real power comes later, with rendering many 3D objects, multplying translation matrices in parallel (the <strong>real</strong> power behind GPUs), and texture and light rendering. This comes with a bit of a learning curve, though.</p>

<h2>Lesson 2: Color and depth</h2>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson2.html">Lesson 2</a></p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7252/13437256473%5F0fb7b032b8.jpg" alt=""/></p>

<p>The lesson2 page draws a red square with a Z of 1, putting at the very back of the rendering space, and a blue diamond with a Z of 0, putting it, theoretically in front of the square. There are three buttons which change the order in which the objects are rendered, one of which deliberately renders them out of order to illustrate the need to explicly turn depth checking on.</p>

<p>We'll get to depth issues shortly. Let's cover colors first.</p>

<h3>Fragment color is calculated from surrounding vertex colors</h3>

<p>If you want an object to be a solid color, each of its vertices must be defined to be that color. If vertices are different colors, the object is rendered as a gradient between the vertex colors. Since most rendering in WebGL is done with triangles, this can lead to some neat effects, such as this simple color "wheel", where the triangle vertices are red, green, and blue:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7456/13437256093%5F00532e899a%5Fo.png" alt=""/></p>

<p>Now let's see how to get colors assigned to our vertices.</p>

<h3>OpenGL variable types</h3>

<p>The <a href="https://web.archive.org/web/20170702094731/https://www.khronos.org/registry/gles/specs/2.0/es%5Ffull%5Fspec%5F2.0.25.pdf">OpenGL ES 2.0 spec</a> states that there are 4 basic types of shader variables:</p>

<blockquote>
<p><em>Vertex attributes</em> are the per-vertex values specified in (...). <em>Uniforms</em> are per-program variables that are constant during program execution. <em>Samplers</em> are a special form of uniform used for texturing. <em>Varying variables</em> hold the results of vertex shader execution that are used later in the pipeline.</p>


</blockquote>

<p>Vertex attributes are declared in the vertex shader with "attribute", e.g.:</p>



<pre><code>attribute vec4 a&#95;color;
</code></pre>



<p>Data is fed to them through buffers, and they are used to hold vector or matrix data, suitable for coordinates, colors, or translation matrices. However, they are only accessible in vertex shaders, which don't set color.</p>

<p>Varing variables are declared with "varing", e.g.:</p>



<pre><code>varying   vec4 v&#95;color;
</code></pre>



<p>They can share data between a vertex and fragment shaders. So to have JavaScript set a color, you buffer it and feed it to an attribute, have the vertex shader read the color and set it to a varying variable, and have the fragment shader read it from there. The fragment shader can then use the varying variable to set gl_FragColor.</p>

<h3>Adding color, simple versus cheap</h3>

<p>There are two basic ways to feed color data to a shader. First, after the vertex buffer has been fed to the shader, you can bind a new buffer with color data and feed that to the shader next. For rendering simple scenes, this is fine and is easier to grok when reading the code.</p>

<p>However, binding buffers is expensive. If you are rendering many objects, this will slow your program down, possibly making animation happen at a lower FPS. The alternative is to interlace the vertex and color data, and use calls to gl.vertexAttribPointer to explain to the shader the size of the "stride", and what offsets in the stride are for what attribute. This is generally referred to as creating a "mesh".</p>

<p>Let's go over both methods. The following shaders will be used:</p>



<pre><code>// Vertex
attribute vec2 vertexCoord;
attribute vec3 a&#95;color;
varying   vec3 v&#95;color;
void main(void) &#123;
    gl&#95;Position = vec4(vertexCoord, 0, 1);
    v&#95;color = a&#95;color;
&#125;

// Fragment
precision mediump float;
varying   vec3 v&#95;color;
void main(void)&#123;
    gl&#95;FragColor = vec4(v&#95;color, 1);
&#125;
</code></pre>



<p>The vertex shader has an additional attribute, a 3 element vector a_color. After setting the vector position, the vertex shader sets the varying variable v_color to match the attribute a_color.</p>

<p>The fragment shader must now start out by setting what precision to use for floats. Why's that? Page 36 of the <a href="https://web.archive.org/web/20170702094731/http://www.khronos.org/registry/gles/specs/2.0/GLSL%5FES%5FSpecification%5F1.0.17.pdf">OpenGL ES Shading Language definition</a> has this to say about the precisions for different variable types:</p>

<blockquote>
<p>The vertex language has the following predeclared globally scoped default precision statements:</p>

<pre>precision highp float;
precision highp int;
precision lowp sampler2D;
precision lowp samplerCube;</pre>

<p>The fragment language has the following predeclared globally scoped default precision statements:</p>

<pre>precision mediump int;
precision lowp sampler2D;
precision lowp samplerCube;</pre>


</blockquote>

<p>Simply put, the fragment shader has no default precision for floats. Even though it behaved well when we used constant values for colors before, attempting to use float variables without a declared precision will cause the shader program to not compile. So we can either use the global float precision declaration, as I have above, or explicitly set the precision of just the v_color variable with something like this:</p>



<pre><code>varying mediump vec3 v&#95;color;
</code></pre>



<p>Lastly, the fragment shader above sets gl_FragColor to the varying variable, taking on an alpha of 1 (fully opaque). Now let's look at the two methods to get color data to the shaders. Note that the shaders don't change, only the use of bindings and pointers from JavaScript.</p>

<p><strong>The simple method</strong></p>

<p>Bind a buffer for vertices, and another for colors. Note the use of "getAttribLocation" here. In the lesson1 page, there was only one attribute, which will always have an index of 0. With more than one attribute, you must seek each one's index, as some WebGL engines index them in the order they are declared in the source code (WebKit), and some alphabetize them first (Mozilla).</p>



<pre><code>// Buffer vertices
gl.bindBuffer(gl.ARRAY&#95;BUFFER, gl.createBuffer());
gl.bufferData(gl.ARRAY&#95;BUFFER, new Float32Array(&#91;
     0.0,  0.5,
    -0.5, -0.5,
     0.5, -0.5
&#93;), gl.STATIC&#95;DRAW);

var loc = gl.getAttribLocation(shader, &#34;vertexCoord&#34;);
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

// Buffer colors
gl.bindBuffer(gl.ARRAY&#95;BUFFER, gl.createBuffer());

gl.bufferData(gl.ARRAY&#95;BUFFER, new Float32Array(&#91;
     1.0,  0.0,  0.0,
     0.0,  1.0,  0.0,
     0.0,  0.0,  1.0
&#93;), gl.STATIC&#95;DRAW);

loc = gl.getAttribLocation(shader, &#34;a&#95;color&#34;);
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, 0);
</code></pre>



<p><strong>The cheap method</strong></p>

<p>Bind one buffer, include X/Y and RGB for each vertex, and describe the array layout to the attribute pointers. Note that the last two variables passed to vertexAttribPointer are explicitly in bytes, so they must be calculated based on how many bytes are in a Float32 (since that's the datatype of the array passed to the buffer), hence the business with "BYTES_PER_ELEMENT" below.</p>



<pre><code>gl.bindBuffer(gl.ARRAY&#95;BUFFER, gl.createBuffer());
gl.bufferData(gl.ARRAY&#95;BUFFER, new Float32Array(&#91;
//  |--coords--|------colors------|
//    X     Y     R     G     B
     0.0,  0.5,  1.0,  0.0,  0.0,
    -0.5, -0.5,  0.0,  1.0,  0.0,
     0.5, -0.5,  0.0,  0.0,  1.0
&#93;), gl.STATIC&#95;DRAW);

var stride      = 5 &#42; Float32Array.BYTES&#95;PER&#95;ELEMENT;
var colorOffset = 2 &#42; Float32Array.BYTES&#95;PER&#95;ELEMENT;

var loc = gl.getAttribLocation(shader, &#34;vertexCoord&#34;);
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, stride, 0);

loc = gl.getAttribLocation(shader, &#34;a&#95;color&#34;);
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, stride, colorOffset);
</code></pre>



<h3>drawElements versus drawArrays</h3>

<p>After the vertices and colors are buffered, the lesson2 page renders the scene using this technique:</p>



<pre><code>var indices = &#91;
    0, 1, 2,
    1, 2, 3,

    4, 5, 6,
    5, 6, 7
&#93;;
gl.bindBuffer(gl.ELEMENT&#95;ARRAY&#95;BUFFER, gl.createBuffer());
gl.bufferData(gl.ELEMENT&#95;ARRAY&#95;BUFFER, new Uint16Array(indices), gl.STATIC&#95;DRAW);

gl.clear(gl.COLOR&#95;BUFFER&#95;BIT);
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED&#95;SHORT, 0);
</code></pre>



<p>The drawElements method uses index numbers of buffered vertices rather than rending the raw vertex points in the order they were buffered. This is useful if, as in the lesson2 example, you are rendering the same vertices in different orders based on user input, and it is also useful if you are rendering a 3D object (say, a cube), and wish to share vertex points along separate faces.</p>

<h3>Checking for depth</h3>

<p>Depth checking is off by default, in which case fragments are rendered in the order the are processed by the shader, with no regard for the point's Z value (so long as the value is between -1 and 1, that is). Depth checking can be turned on with the following:</p>



<pre><code>gl.enable(gl.DEPTH&#95;TEST);
</code></pre>



<p>And it is turned off by passing the same value to gl.disable. When depth checking is turned on, a fragment is only rendered if nothing is in front of it... or at least, that's the idea. In reality, the fragment is rendered if it passes whichever depth test is declared by the gl.depthFunc method. The depth buffer is initialized to all 1s, and by default, a fragment is rendered if its Z value is less than the corresponding point in the depth buffer, in which case the fragment's Z value overwrites what is in the depth buffer for that point.</p>

<p>Since each point starts out as 1, if depth checking is enabled, by default nothing is rendered with a Z value of exactly 1. Since my lesson2 page has the red square vertices at Z=1, I had to update the depth checking function to compare with less than or equal with this call:</p>



<pre><code>gl.depthFunc(gl.LEQUAL);
</code></pre>



<h2>Lesson 3: Rotating a cube</h2>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson3.html">Lesson 3</a></p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm3.staticflickr.com/2817/13437125105%5F5064a8121d.jpg" alt=""/></p>

<h3>Translation matrices</h3>

<p>A translation matrix in WebGL is literally a 4 by 4 matrix from linear algebra. It is multiplied against 3D coordinates to produce new, translated coordinates, for the purpose of reposition, rotating, or scaling objects. In case your memories of Math Analysis class have succumbed to the ravages of time, <a href="https://web.archive.org/web/20170702094731/http://cautery.blogspot.com/2012/11/the-math-behind-html5-context-transforms.html">here is a quick refresher</a> from my old "Medicine for the Sky" blog on how matrix algebra works, along with some 2D rendering examples.</p>

<p>A non-trivial WebGL program will likely have multiple translation matrices - one for positioning an object in the scene, one (or several) for rotation, and one for positioning the "camera"... except there really isn't a camera, so that would just be a matrix applied to all objects the same way (the camera is moving up, so all objects must move down, for instance).</p>

<p>In the WebGL model, translation matrices use the following formulae:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7227/13437125005%5Ffc0018cf54%5Fo.png" alt=""/></p>

<p>Something that might jump out at you is that the matrix is column-major, meaning as values are read into the matrix, they fill it up one column at a time instead of one row at a time. This can cause some confusion, since to buffer data into a matrix shader variable, it starts out in JavaScript as a flat array, typically declared like this:</p>



<pre><code>var matrix = &#91;
    a, b, c, d,
    e, f, g, h,
    i, j, k, l,
    m, n, o, p
&#93;;
</code></pre>



<p>...in row-major order, diagonally transposed from the OpenGL spec for a matrix. This is such a common pain point that many matrix libraries meant for use with WebGL contain a function to swap array values between column and row major layouts.</p>

<p>There are four basic types of values in a translation matrix: Scaling, shearing, offsets, and homogenous modifiers. Offsets [m, n, and o] are the simplest, they add a fixed value to an axis. For instance, to move something to the right, make m a positive value.</p>

<p>Scaling values (a, f, and k) multiply the value of an axis, making it bigger or smaller in that direction. Setting f to 2, for example, gives us an equation of <em>y' = 2y</em>. Shearing values (b, c, e, g, i, and j) are similar. They modify their axis based on the value of another axis. If a is 1 and e is 1, we have the equation _x' = x + y, creating a 45 degree shear on the x axis.</p>

<p>Rotations happen from precise combinations of shears, typically using sine and cosine values of the angle you want to rotate the object to. A good primer for the specific rotation equations for each axis is the "In three dimensions" section of the Wikipedia page on <a href="https://web.archive.org/web/20170702094731/https://en.wikipedia.org/wiki/Rotation%5Fmatrix#In%5Fthree%5Fdimensions">rotation matrices</a>, which shows these rotation rules:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm3.staticflickr.com/2931/13437495254%5F5d92d65376%5Fo.png" alt=""/></p>

<p>For the lesson3 example, I've taken a unit cube with different colored faces, twisted it to the right 45 degrees, and then tipped in forward 45 degrees, which makes the cube appear to be resting on a point, as shown in the image above.</p>

<p>To accomplish this, I rotated along the Y axis (the vertical axis), which is the same motion as twisting the top or bottom face of a Rubik's cube. Then I rotated along the X axis (the horizontal axis), which is the same motion as twisting a Rubik's cube's left or right face.</p>

<h3>Order is important</h3>

<p>If I rotated the above cube in the opposite order, but the same amounts, I would get this:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm3.staticflickr.com/2916/13437125175%5F93f48d5b71.jpg" alt=""/></p>

<p>The reason is pretty straightforward: Take a cube that's facing you and tip it forward. It is now on its bottom <em>edge</em>, rather than a corner. Now take the cube resting on its edge and rotate it to the right... and it is still resting on its edge.</p>

<p>The matrices I used are the following:</p>



<pre><code>var a = Math.SQRT1&#95;2; // Also the sine and cosine of 45 degrees

var xRotate = &#91;
    1, 0, 0, 0,
    0, a,-a, 0,
    0, a, a, 0,
    0, 0, 0, 1
&#93;;

var yRotate = &#91;
    a, 0,-a, 0,
    0, 1, 0, 0,
    a, 0, a, 0,
    0, 0, 0, 1
&#93;;
</code></pre>



<p>Luckily, JavaScript already has the square root of one-half as a constant, which matches both the sign and cosine of a 45 degree angle (a 1, 1, &radic;2 triangle, whose adjacent and opposite angles are the same length), which means in this case the CPU won't have to do any real math. Plug the predefined constant into the rotation definitions from Wikipedia, and WebGL happily rotates the object as expected, with this vertex shader code, using nothing but GPU:</p>



<pre><code>    uniform   mat4 x&#95;rotate;
    uniform   mat4 y&#95;rotate;
    attribute vec3 vertexCoord;
    attribute vec3 a&#95;color;
    varying   vec3 v&#95;color;
    void main(void) &#123;
        gl&#95;Position = x&#95;rotate &#42; y&#95;rotate &#42; vec4(vertexCoord, 1);
        v&#95;color = a&#95;color;
    &#125;
</code></pre>



<p>Note that the matrix multiplication happens in the opposite order of the action you want. The original vertex positions are referenced <em>last</em>, and the action happens from right to left.</p>

<p>The rotation matrices are "uniform" variable types, meaning they do not change during a draw operation, and which are moderately expensive to set. Typically you set them as infrequently as possible. In lesson3's case, they are both set once, and then the vertices are fed in and the scene drawn:</p>



<pre><code>xLoc = gl.getUniformLocation(shader, &#34;x&#95;rotate&#34;);
yLoc = gl.getUniformLocation(shader, &#34;y&#95;rotate&#34;);

gl.uniformMatrix4fv(xLoc, false, xRotate);
gl.uniformMatrix4fv(yLoc, false, yRotate);

gl.clear(gl.COLOR&#95;BUFFER&#95;BIT | gl.DEPTH&#95;BUFFER&#95;BIT);
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED&#95;SHORT, 0);
</code></pre>



<p>According to Euler's <a href="https://web.archive.org/web/20170702094731/https://en.wikipedia.org/wiki/Euler%27s%5Frotation%5Ftheorem">rotation theorem</a>, multiple rotations in 3D space can be represented by a single rotation. This can easily be shown by multiplying our two matrices above together to get a single matrix, and plugging that into the code. Indeed, <a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson3b.html">Lesson 3b</a> shows the same rotation with a single matrix.</p>

<p>To further illustrate why order is important, here are the resultant rotation matrices when the originals are multiplied in both orders, with the help of our good friend Wolfram Alpha:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7409/13437255393%5F4ef90ff862%5Fo.png" alt=""/> (X times Y)</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm4.staticflickr.com/3737/13437255293%5Fca6f2567e1%5Fo.png" alt=""/> (Y times X)</p>

<p>The X times Y matrix matches the single rotation matrix used in Lesson 3b (remember, the JavaScript declaration looks transposed, and since a is &radic;.5, a<sup>2</sup> will just be .5), and rotates the cube down to the same corner as lesson3 does:</p>



<pre><code>var rotate = &#91;
    a, -.5, -.5, 0,
    0,   a,  -a, 0,
    a,  .5,  .5, 0,
    0,   0,   0, 1
&#93;;
</code></pre>



<h2>Representing rotations abstractly</h2>

<p>Until now, we've thought about rotation just in regard to specific translation matrices multiplied together in a specific order. It may not be self-evident that more abstraction is needed until you see a consequence of not considering how to represent rotations. Let's take our cube and add in some user input to adjust the matrices.</p>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson4.html">Lesson 4</a> takes the same cube from lesson 3, and adds in support for mouse drag events to adjust the rotation. Horizontal drags rotate the cube across the Y axis, and vertical drags rotate across the X axis.</p>

<p>The vertex and index data is buffered as before, but setting the translation matrices and final rendering is now moved to its own function:</p>



<pre><code>function draw() &#123;
    var xs = Math.sin(xAngle);
    var xc = Math.cos(xAngle);
    var ys = Math.sin(yAngle);
    var yc = Math.cos(yAngle);

    var xRotate = &#91;
        1,  0,  0, 0,
        0, xc, xs, 0,
        0,-xs, xc, 0,
        0,  0,  0, 1
    &#93;;

    var yRotate = &#91;
        yc, 0,-ys, 0,
         0, 1,  0, 0,
        ys, 0, yc, 0,
         0, 0,  0, 1
    &#93;;

    xLoc = gl.getUniformLocation(shader, &#34;x&#95;rotate&#34;);
    yLoc = gl.getUniformLocation(shader, &#34;y&#95;rotate&#34;);

    gl.uniformMatrix4fv(xLoc, false, xRotate);
    gl.uniformMatrix4fv(yLoc, false, yRotate);

    // Clear color and depth buffers
    gl.clear(gl.COLOR&#95;BUFFER&#95;BIT | gl.DEPTH&#95;BUFFER&#95;BIT);
    gl.drawElements(gl.TRIANGLES, numIndices, gl.UNSIGNED&#95;SHORT, 0);
&#125;
</code></pre>



<p>Note that I'm now explicitly using the sine/cosine math to determine matrix values. Now all we need is a mechanism to translate mouse drags to angles:</p>



<pre><code>// Set mouse down and mouse up to both update lastX/Y with the current mouse position
window.onmousedown = window.onmouseup = function(e) &#123;
    lastX = e.pageX;
    lastY = e.pageY;
&#125;

// If a mouse button is down add a delta to the angles, update lastX/Y, and repaint.
window.onmousemove = function(e)&#123;
    var buttonDown = e.buttons == null ? e.which : e.buttons;
    if (!buttonDown) return;

    yAngle -= (e.pageX - lastX) / 256;
    lastX = e.pageX;

    xAngle -= (e.pageY - lastY) / 256;
    lastY = e.pageY;

    draw();
&#125;
</code></pre>



<p>The <em>e.which : e.buttons</em> business is, I believe, a previously undiscovered simple mechanism for a cross-browser (as far as Mozilla and WebKit go, anyway) mouse buttonpress detector. There is no explicit animation going on here with calls to requestAnimationFrame or equivalent; I am simply triggering a redraw on each mouse move where a button was down.</p>

<p>First, open lesson 4 and play around with mouse drags to get a feel for how the rotation works. Note that up/down drags always work as expected, but pay attention to left/right drags when the cube has been previously tilted forward or backward to a new face.</p>

<p>Odd, right? When the cube is not tilted forward or backward, left and right drags move the cube left and right. If you drag the cube forward or backward 90 degrees, the left/right drags now perform a twisting rotation along the Z axis (the axis pointing out of the screen at you, representing depth); this is the same motion as rotating a Rubik's cube's front or back faces.</p>

<p>Dragging the cube an additional 90 degrees forward or back will make left/right drags now work in reverse: dragging to the right rotates the cube to the left.</p>

<p>Why is this? In essence, we've created a <a href="https://web.archive.org/web/20170702094731/http://en.wikipedia.org/wiki/Gimbal">gimbal</a>, based solely on multiplying our X and Y rotation matrices. The order of the multiplication determines which axis is a child, meaning its basis of orientation is the current angle of the parent axis.</p>

<p>If we throw in a third rotation axis, we can see an example of the phenomenon known as <a href="https://web.archive.org/web/20170702094731/https://en.wikipedia.org/wiki/Gimbal%5Flock">gimbal lock</a>.</p>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson4b.html">Lesson 4b</a> behaves much the same as lesson 4, however dragging left/right while holding the right mouse button now spins the cube on the Z axis. In the new code, I've added a third rotation matrix into the vertex shader:</p>



<pre><code>uniform   mat4 x&#95;rotate;    /&#42; Translation matrix for rotating along the X axis &#42;/ 
uniform   mat4 y&#95;rotate;    /&#42; Translation matrix for Y axis rotation&#42;/ 
uniform   mat4 z&#95;rotate;    /&#42; Translation matrix for Z axis rotation&#42;/ 
attribute vec3 vertexCoord; /&#42; x, y and z coordinates of current vertex &#42;/ 
attribute vec3 a&#95;color;     /&#42; RGB of current vertex, sent interleaved with vertex coords &#42;/ 
varying   vec3 v&#95;color;     /&#42; Color sent to the fragment shader &#42;/ 
void main(void) &#123; /&#42; Set vertex position with above variable, at normal scale &#42;/ 
    gl&#95;Position = x&#95;rotate &#42; y&#95;rotate &#42; z&#95;rotate &#42; vec4(vertexCoord, 1);
    v&#95;color = a&#95;color;
&#125;
</code></pre>



<p>...a branch to check for whether the left or right mouse button is being used, and choosing the appropriate axis (as well as a quick function to disable the right-click menu):</p>



<pre><code>window.onmousemove = function(e)&#123;
    var buttonDown = e.buttons == null ? e.which : e.buttons;
    if (!buttonDown) return;

    if (buttonDown &gt; 1) &#123;
        zAngle -= (e.pageX - lastX) / 256;
        lastX = e.pageX;
    &#125; else &#123;
        yAngle -= (e.pageX - lastX) / 256;
        lastX = e.pageX;
    &#125;

    xAngle -= (e.pageY - lastY) / 256;
    lastY = e.pageY;

    draw();
&#125;

window.oncontextmenu = function() &#123; return false; &#125;
</code></pre>



<p>The order of multiplying the matrices in the vertex shader puts the Z rotation as the child of both Y and X, meaning any changes to either X or Y changes the orientation of Z. If this were a physical gimbal, then Z would be the innermost ring - always able to rotate freely, but its "north pole", so to speak, follows the movements of the X and Y rings.</p>

<p>Experiment with lesson4b a little to see how gimbal orientation behaves. Right-click dragging left and right will spin the cube on its Z axis, however the Z axis is always through the blue and red faces. If you left-click and rotate the cube to the right 90 degrees, the cube's red and blue faces are now oriented to the X axis. Now if you right-click and drag right or left, the cube rotates up or down, the same motion as left-click dragging up or down. This is one example of gimbal lock.</p>

<p>There are a number of ways to prevent this, and in the case of WebGL or OpenGL, they all have one thing in common: Abstracting rotations somehow. Track the rotations independently of the vertex shader, use maths to premultiply rotations together, and passing a new rotation matrix to the shader. There are a number of methods to do this, and I'll go over a couple of them here.</p>

<h3>Tait-Bryan angles plus tracking the last rotation</h3>

<p>The simplest approach code-wise is to leave everything as-is, and on mouse-up, creating a translation matrix representing the current rotation, and reset the X, Y, and Z angles all back to 0. Pass that matrix in as the "initial condition" to the vertex shader, where it will be multiplied against the original cube coordinates first.</p>

<p>This requires our first foray into tracking a changing translation matrix on the JavaScript side, and this is the space where glMatrix, EWGL, Sylvester, and their ilk shine, with lots of optimizations for making transpositions, matrix multiplications, etc. as fast as possible. Why the focus on this optimization? Because the GPU is an order of magnitude faster at this type of math than a CPU, so all the work done JavaScript side instead of shader-side will naturally be your bottleneck.</p>

<p>We start in the shader, declaring a new uniform variable for the "initial" matrix:</p>



<pre><code>uniform   mat4  initial;    /&#42; Orientation from last rotation set &#42;/
</code></pre>



<p>And plug it into the gl_position calculation:</p>



<pre><code>gl&#95;Position = x&#95;rotate &#42; y&#95;rotate &#42; z&#95;rotate &#42; initial &#42; vec4(vertexCoord, 1);
</code></pre>



<p>The "initial" matrix will always be the last set of rotations multiplied together, and the new orientation starting point. The x_, y_, and z_rotate matrices function as before, on only one axis each, functioning as Tait-Bryan angles. This is nothing new, it is exactly how they functioned before, rotating each axis in turn, allowing orientation to any final position. This is what is commonly referred to as Euler angles, but this is slightly inaccurate: Proper Euler angles refer to only two axes, with the first and last rotations being on the same axis.</p>

<p>Say what? For example, rotate on X, then on Y, then on X again. Think that through, and you'll see that with this method you can also accomplish any orientation, with the added bonus of being able to visualize it easier from a single reference plane. Tait-Bryan is the same thing, just using each of the three axes once, which better fits the UI model.</p>

<p>Now that we have a place to multiply the new matrix, there is some complementary code to set the initial value of "initial", and to multiply the new rotations into the matrix. Our good friend Wolfram Alpha again comes to the rescue, illustrating how to multiply three translation matrices together. In the image below, the sine and cosine of the X angle are a and b, Y is c and d, and Z is e and f:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm4.staticflickr.com/3717/13437494524%5Fd7d9f97f6e%5Fo.png" alt=""/></p>

<p>We can represent that with a simple JavaScript array (remember, everything is transposed):</p>



<pre><code>var n = &#91;
     d &#42; f, b &#42; e + a &#42; c &#42; f, a &#42; e - b &#42; c &#42; f, 0,
    -d &#42; e, b &#42; f - a &#42; c &#42; e, b &#42; c &#42; e + a &#42; f, 0,
         c,            -a &#42; d,             b &#42; d, 0,
         0,                 0,                 0, 1
&#93;;
</code></pre>



<p>Additionally, we need to multiply the above array, showing the current rotations, by the old values for "initial", and update that array. If you browsed through the "Medicine for the Sky" entry on translation matrices, you'll know that to multiply them, you are performing a dot-product on each element of the corresponding row of one matrix, and column from the other. This works out to be a pretty straightforward Array.map step:</p>



<pre><code>initial = n.map(function(val, ndx) &#123;
    var x = ndx % 4, y = ndx - x;
    return n&#91;x&#93; &#42; o&#91;y&#93; + n&#91;x+4&#93; &#42; o&#91;y+1&#93; + n&#91;x+8&#93; &#42; o&#91;y+2&#93; + n&#91;x+12&#93; &#42; o&#91;y+3&#93;;
&#125;);
</code></pre>



<p>(Here "n" is a clone of initial.) I want to update initial after every mouse up event, so I'm rewriting the window.mouseup function like so:</p>



<pre><code>window.onmouseup = function(e) &#123;
    var a = Math.sin(xAngle);
    var b = Math.cos(xAngle);
    var c = Math.sin(yAngle);
    var d = Math.cos(yAngle);
    var e = Math.sin(zAngle);
    var f = Math.cos(zAngle);

    var n = &#91;
         d &#42; f, b &#42; e + a &#42; c &#42; f, a &#42; e - b &#42; c &#42; f, 0,
        -d &#42; e, b &#42; f - a &#42; c &#42; e, b &#42; c &#42; e + a &#42; f, 0,
             c,            -a &#42; d,             b &#42; d, 0,
             0,                 0,                 0, 1
    &#93;; // new
    var o = initial.slice(); // old

    initial = n.map(function(val, ndx) &#123;
        var x = ndx % 4, y = ndx - x;
        return n&#91;x&#93; &#42; o&#91;y&#93; + n&#91;x+4&#93; &#42; o&#91;y+1&#93; + n&#91;x+8&#93; &#42; o&#91;y+2&#93; + n&#91;x+12&#93; &#42; o&#91;y+3&#93;;
    &#125;);

    xAngle = yAngle = zAngle = 0;
&#125;
</code></pre>



<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson4c.html">Lesson 4c</a> uses this method, presenting the user with much more intuitive rotations. Unfortunately, this method is computationally expensive (particularly the 48 uncached array lookups on every mouse up), which would drop your FPS rate if many objects were being tracked this way.</p>

<p>A better alternative is Quaternions.</p>

<h3>Quaternions</h3>

<p>As I mentioned above, Euler's rotation theorem assures us that any set of rotations can be referenced by a single rotation, expressed in <a href="https://web.archive.org/web/20170702094731/https://en.wikipedia.org/wiki/Axis-angle%5Frepresentation">Axis-angle representation</a> as a unit vector for the axis and an angle of rotation on that axis.</p>

<p>There are known formulae for combining two Axis-angles into one, e.g., given an existing axis-angle in a 1x3 rotation vector v, and [w,&theta;] is the axis and angle we wish to rotate that with, they can be combined using:</p>

<pre>v<sub>rot</sub> = v cos &theta; + (w &times; v) sin &theta; + w(w &sdot; v)(1 - cos &theta;)</pre>

<p>...where w &times; v is the cross-product of w and v, and w &sdot; v being the dot-product. This can also be turned into a 3x3 rotation matrix R with this formula:</p>

<pre>R = I + sin &theta;[k]<sub>x</sub> + (1 - cos &theta;)(kk<sup>t</sup> - I)</pre>

<p>...where k<sup>t</sup> is a vector tangent to k, I is a 3x3 identity matrix, and [k]<sub>x</sub> is a 3x3 cross product matrix of vector k expressed as:</p>



<pre><code>|  0  -k3  k3 |
|  k3  0  -k1 |
| -k2  k1  0  |
</code></pre>



<p>At a glance, turning that into WebGL + JavaScript code would be a chore, and would probably not reduce our number of calculations. There is, fortunately, a way to turn axis-angles into algebraic expressions that can be multiplied together natively, and easily turned into a rotation matrix. Enter Quaternions.</p>

<p>Quaternions present you with an unusual concept right out of the gate: what if there are other types of imaginary numbers than just "i"? How would they behave?</p>

<p>In 1843, Irish natural philosopher William Rowan Hamilton put forth a definition for three imaginary constants, each representing an axis in Cartesian space. <em>i</em>, <em>j</em>, and <em>k</em> representing the X, Y, and Z axes, respectively. Squaring any of them gives -1, just like in traditional complex numbers, however multiplying them together in sequence <strong>also</strong> gives -1. The equation and its corollaries are normally given like this:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7224/13437495644%5F3cde252925%5Fo.png" alt=""/></p>

<p>Pretty wild. The multiplications aren't commutative (ij != ji), which makes sense when you remember that they represent operations in 3d space. Rotating on the X and then the Y axis has a different effect that rotating on Y and then X, as discussed above. As a starting point for trying to untangle what happens when the imaginary constants are combined, think of this:</p>

<p><code>i<sup>2</sup> = -1</code>, just as you remember from math class.</p>

<p><code>ijk = -1</code>, as defined in the new formula.</p>

<p>If i(jk) = -1, then jk must also equal i. Similarly, k<sup>2</sup> also = -1, so (ij) must = k. Some trial and error should lead you to independently discover all the equalities listed in the equation image above, and I'll leave that as an exercise for you, if you're interested.</p>

<p>There are a number of sites describing quaternions and how they relate to 3D graphics, however the two I found most useful in showing how the math works are one of Hamilton's original papers on the topic from circa 1850, <a href="https://web.archive.org/web/20170702094731/http://www.maths.tcd.ie/pub/HistMath/People/Hamilton/OnQuat/OnQuat.pdf">On Quaternions, or on a New System of Imaginaries in Algebra</a> and a 2001 paper out of the CompSci department of UNC, <a href="https://web.archive.org/web/20170702094731/http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.6183&amp;rep=rep1&amp;type=pdf">Quaternions and Rotations in 3 Space</a> by Leandra Vicci, both of which are good if you want the juicy details and aren't afraid of copious notation with nebulous decriptions.</p>

<p>My description will be briefer. A quaternion can be represented by 4 variables, w, representing the rotation angle (in radians), and x,y, and z, representing a vector. The w variable stands alone (not to be confused with the homogenous coordinate w, which I'll discuss in the next section), while x,y, and z are multiplied by the imaginary constants above, to form the algebraic expression:</p>



<pre><code>w + xi + yj + zk
</code></pre>



<p>When multiplying two quaternions together, the properties of combining imaginaries comes into play, making the resulting product simpler. For example, if we multiply the two quaternions Q(w,x,y,z) and Q(W,X,Y,Z), this happens:</p>



<pre><code>(w + xi + yj + zk) &#42; (W + Xi + Yj + Zk)
wW + wXi + wYj + wZk + xiW + xiXi + xiYj + xiZk + yjW + yjXi + yjYj + yjZk + zkW + zkXi + zkYj + zkZk
</code></pre>



<p>Now let's simplify the i<sup>2</sup>, j<sup>2</sup>, and z<sup>2</sup> to be -1:</p>



<pre><code>wW + wXi + wYj + wZk + xiW + -xX + xiYj + xiZk + yjW + yjXi + -yY + yjZk + zkW + zkXi + zkYj + -zZ
</code></pre>



<p>Now the terms with two imaginaries multiplied together can be simplified to their single-imaginary counterparts:</p>



<pre><code>wW + wXi + wYj + wZk + xiW + -xX + xYk + xZ-j + yjW + yX-k + -yY + yZi + zkW + zXj + zY-i + -zZ
</code></pre>



<p>Now rearrange the sign indicators to make that more legible:</p>



<pre><code>wW + wXi + wYj + wZk + xiW - xX + xYk - xZj + yjW - yXk - yY + yZi + zkW + zXj - zYi - zZ
</code></pre>



<p>Lastly, sort the terms by which imaginaries they use:</p>



<pre><code>wW - xX - yY - zZ + wXi + xiW + yZi - zYi + wYj - xZj + yjW + zXj + wZk + xYk - yXk + zkW =
(wW - xX - yY - zZ) + i(wX + xW + yZ - zY) + j(wY - xZ + yW + zX) + k(wZ + xY - yX + zW)
</code></pre>



<p>This leaves us with 4 expressions, representing the product quaternion Q(w',x',y',z'):</p>



<pre><code>w&#39; = wW - xX - yY - zZ,
x&#39; = wX + xW + yZ - zY,
y&#39; = wY - xZ + yW + zX,
z&#39; = wZ + xY - yX + zW
</code></pre>



<p>Interestingly, each of these sixteen terms uses each combination of the original terms exactly once. This turns out to be important. The sum of the squares of the product terms is equal to the product of the sum of the squares of the original terms. By that I mean:</p>

<pre>(w'<sup>2</sup> + x'<sup>2</sup> + y'<sup>2</sup> + z'<sup>2</sup>) = (w<sup>2</sup>+x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>) (W<sup>2</sup>+X<sup>2</sup>+Y<sup>2</sup>+Z<sup>2</sup>)</pre>

<p>A quick check on Wolfram Alpha will show that this is right:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm4.staticflickr.com/3726/13437124575%5F075e037802%5Fb.jpg" alt=""/></p>

<p>Why is that significant? When we introduce unit vectors and unit quaternions ("unit" in this case meaning the sum of the squared terms equals 1), we see that the sum of the squares of each quaternion and the product quaternion are all one. Then we can make use of Pythagorean trigonometric identity:</p>

<pre>cos<sup>2</sup> &theta; + sin<sup>2</sup> &theta; = 1</pre>

<p>...where cos &theta; subs in for w, where &theta; is the "magnitude" of the quaternion (more on that in a minute). sin &theta; gets multiplied by (xi + yj + zk), making the equation for the quaternion expand to:</p>



<pre><code>cos(n) + sin(n)ix + sin(n)jy + sin(n)kz
</code></pre>



<p>Since the [x,y,z] is a unit vector (x<sup>2</sup> + y<sup>2</sup> + z<sup>2</sup> = 1), the square of the terms reduce down to the Pythagorean identity above. Without getting bogged down much more in the math, here's the coup de grce: The "magnitude", theta, is twice the angle of rotation, phi. The reason is perhaps not intuitive, but it is essentially this: To take a vector with no rotation, and apply rotation to it, you multiply it by a quaternion and its inverse, so that the original vector's length and orientation are unchanged, and each of the two multiplications rotates the vector by theta. The equation is typically shown as this:</p>



<pre><code>R(v) = qvq&#42;
</code></pre>



<p>...where v is the original vector, R(v) is a quaternion representing the same vector, rotated, q is a quaternion, and q* is its multiplicative inverse (or conjugate {w - ix - jy -kz}, since those two have the same value for unit quaternions). David Eberly's 1999 paper <a href="https://web.archive.org/web/20170702094731/http://www.geometrictools.com/Documentation/Quaternions.pdf">Quaternion Algebra and Calculus</a> dives into the proof for that in some more detail.</p>

<p>Extracting an angle and vector out of a quaternion would be straightforward (just take the cos<sup>-1</sup> of w, and apply some algebra to undo the rest), however as it turns out, this is unnecessary in the context of WebGL rotations. Why? Because quaternions can be cast directly to 4 by 4 translation matrices without any additional trigonometry. The conversion, from <a href="https://web.archive.org/web/20170702094731/https://en.wikipedia.org/wiki/Quaternions%5Fand%5Fspatial%5Frotation">Wikipedia</a>, is this:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7445/13437495404%5F44af5d710d%5Fo.png" alt=""/></p>

<p>Since we will only be working with unit quaternions, where the sum of its terms squared is always 1, the diagonal terms can be reduced to 1 - 2n<sup>2</sup> - 2f<sup>2</sup>, where n and f are whichever two terms are subtracted in that matrix element. Now substituting the above a,b, c, and d with our familiar w, x, y, and z, reducing the diagonal terms, and fleshing that out to a 4 by 4 matrix, we get the following transformation from quaternion to rotation matrix:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm3.staticflickr.com/2933/13437495274%5F202da7da16%5Fo.png" alt=""/></p>

<p>So now we have a system that lets us track fewer terms for each rotation, combine them with fewer operations (remember, multiplying two 4 by 4 matrices results in 64 multiplications), and cast them to a single rotation matrix without additional trigonometry. <a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson4d.html">Lesson 4d</a> is a rewrite of the more natural rotation from Lesson 4c, using quaternions to track everything, and simplifying the vector shader to one rotation matrix:</p>



<pre><code>uniform   mat4 rotate;      /&#42; Translation matrix from js quaternion calcs &#42;/
attribute vec3 vertexCoord; /&#42; x, y and z coordinates of current vertex &#42;/ &#92;
attribute vec3 a&#95;color;     /&#42; RGB of current vertex, sent interleaved with vertex coords &#42;/
varying   vec3 v&#95;color;     /&#42; Color sent to the fragment shader &#42;/
void main(void) &#123; &#92;/&#42; Set vertex position with above variable, at normal scale &#42;/
    gl&#95;Position = rotate &#42; vec4(vertexCoord, 1);&#92;
    v&#95;color = a&#95;color;&#92;
&#125;&#92;
</code></pre>



<p>Next we need helper functions to multiply quaternions, and to turn them into rotation matrices:</p>



<pre><code>function multiplyQuaternion(a, b) &#123;
    var w = a&#91;0&#93;, x = a&#91;1&#93;, y = a&#91;2&#93;, z = a&#91;3&#93;,
        W = b&#91;0&#93;, X = b&#91;1&#93;, Y = b&#91;2&#93;, Z = b&#91;3&#93;,
        out = &#91;&#93;;

    out&#91;0&#93; = w&#42;W - x&#42;X - y&#42;Y - z&#42;Z;
    out&#91;1&#93; = w&#42;X + x&#42;W + y&#42;Z - z&#42;Y;
    out&#91;2&#93; = w&#42;Y - x&#42;Z + y&#42;W + z&#42;X;
    out&#91;3&#93; = w&#42;Z + x&#42;Y - y&#42;X + z&#42;W;

    return out;
&#125;

function quaternionToMatrix(a) &#123;
    var w = a&#91;0&#93;, x = a&#91;1&#93;, y = a&#91;2&#93;, z = a&#91;3&#93;,
        wx = w &#42; x &#42; 2, wy = w &#42; y &#42; 2, wz = w &#42; z &#42; 2,
        xy = x &#42; y &#42; 2, xz = x &#42; z &#42; 2, yz = y &#42; z &#42; 2,
        out = &#91;&#93;;

    w = w &#42; w &#42; 2;
    x = x &#42; x &#42; 2;
    y = y &#42; y &#42; 2;
    z = z &#42; z &#42; 2;

    out = &#91;
        1 - y - z,   xy + wz,   xz - wy, 0,
          xy - wz, 1 - x - z,   yz + wx, 0,
          xz + wy,   yz - wx, 1 - x - y, 0,
                0,         0,         0, 1
    &#93;;

    return out;
&#125;
</code></pre>



<p>The mouse handler functions then become much simpler:</p>



<pre><code>// Set mouse down to update lastX/Y with the current mouse position
window.onmousedown = function(e) &#123;
    initX = e.pageX;
    initY = e.pageY;
    working = &#91;1, 0, 0, 0&#93;;
&#125;

// On drags, update working quaternion, multiply with tracking to get a final
// rotation quaternion, call draw()
window.onmousemove = function(e)&#123;
    var buttonDown = e.buttons == null ? e.which : e.buttons;
    if (!buttonDown) return;

    var x = e.pageX - initX, y = e.pageY - initY;
    if (x == 0 &amp;&amp; y == 0) return;

    // Calculate root sum squares of &#91;x,y&#93;
    var dist = Math.sqrt(Math.pow(x-y, 2) + 2 &#42; x &#42; y);

    // Turn distance into rotation angle, find its sine and cosine
    var angle = dist / 256,
        w = Math.cos(angle),
        s = Math.sin(angle);

    // Normalize coordinates, flip signs
    x &#42;= -s/dist;
    y &#42;= -s/dist;

    // Rotate on X/Y plane for normal drags, X/Z plane for right-drags
    working = buttonDown &gt; 1 ? &#91;w, y, 0, x&#93; : &#91;w, y, x, 0&#93;;
    draw(working);
&#125;

window.onmouseup = function(e) &#123;
    tracking = multiplyQuaternion(working, tracking);
    working = &#91;1, 0, 0, 0&#93;;
&#125;
</code></pre>



<p>What I've done with the mousemove function is notable: I'm turning a distance from the original click point into the rotation angle, and normalizing those values to become the rotation axis vector, another way quaternions are surprisingly well-matched to a 3D UI.</p>

<p>Finally, the draw function can be greatly simplified over the previous iteration:</p>



<pre><code>function draw(quat) &#123;
    if (quat == null) quat = tracking;
    else quat = multiplyQuaternion(quat, tracking);
    var rotate = quaternionToMatrix(quat);
    gl.uniformMatrix4fv(rLoc, false, rotate);

    // Clear color and depth buffers
    gl.clear(gl.COLOR&#95;BUFFER&#95;BIT | gl.DEPTH&#95;BUFFER&#95;BIT);
    gl.drawElements(gl.TRIANGLES, numIndices, gl.UNSIGNED&#95;SHORT, 0);
&#125;
</code></pre>



<p>That's it! Convert the tracking quaternion into a rotation matrix, and combine it with an optional quaternion if needed. Pass the resulting rotation matrix to the shader, and let fly. We can rely on mouseup events to update "tracking" with the latest final rotation.</p>

<h2>Orthographic vs. perspective transformation</h2>

<p>The <a href="https://web.archive.org/web/20170702094731/https://www.khronos.org/registry/gles/specs/2.0/es%5Ffull%5Fspec%5F2.0.25.pdf">OpenGL ES 2.0 spec</a> describes how W, the homogenous coordinate, is used to translate coordinates from clip space to device space in section 2.12:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm4.staticflickr.com/3773/13437124915%5F8f658551d8%5Fz.jpg" alt=""/></p>

<p>Divide all the Cartesian coordinates by W. That's it. In an orthographic projection, the 3D object being rendered is simply flattened - W is always 1. If you are looking head-on at a cube rendered orthographically, you just see a square.</p>

<p>Perspective projection, on the other hand, is exactly what they taught you in 8th grade art class: As objects get further away, they converge on the "vanishing point". The straightforward way to do this in WebGL is to link the Z axis to W. If we look at the algebraic equations for translation matrices again...</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7227/13437125005%5Ffc0018cf54%5Fo.png" alt=""/></p>

<p>...we see that setting L to a positive value links higher Z values with higher W, hence dividing the device x and y coordinates by higher numbers, which pushes the pixels closer to the origin point.</p>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson5.html">Lesson 5</a> is a non-interactive example of using this method to render a simple wireframe cube in one-point perspective. The end result looks like this:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm6.staticflickr.com/5217/13437256683%5F70933d2122.jpg" alt=""/></p>

<p>This was accomplished simply by taking an identity matrix and setting L to 1 (remember, the JavaScript matrix layout is transposed):</p>



<pre><code>var perspective = &#91;
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 1,
    0, 0, 0, 1
&#93;;
</code></pre>



<p>What if you want two-point perspective, like looking at the edge of a building, and seeing both sides extend to their respective vanishing points? It's actually easier than you might imagine: Rotate first, then apply the perspective matrix.</p>

<p><a href="https://web.archive.org/web/20170702094731/https://googledrive.com/host/0ByPGrLaHP5fFbFNha2IzVTNxZXM/lesson5b.html">Lesson 5b</a> shows exactly this, taking the same wireframe cube and rotating it 45 degrees across the Y axis. This means that our original higher Z values are now less high, and off to the left, where the right side of the wall originally facing us is now deeper in the frame. Both of these get squished towards the origin, resulting in this effect:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm4.staticflickr.com/3750/13437495954%5Fd283f736b1.jpg" alt=""/></p>

<p>I think that's a good starting off point, and I congratulate you if you've actually managed to plow your way through this. I haven't covered textures or lighting, which are the next logical points to investigate, but will leave it to you to research them if you're so inclined. I also haven't created any objects more complicated than a cube, but I assure you with these basics and a search engine, you're only a couple of steps away from, say, creating a spherical map of Earth behind a torus of Earthsea:</p>

<p><img src="https://web.archive.org/web/20170702094731im_/https://farm8.staticflickr.com/7270/13437124415%5Ff4b6fd9e45.jpg" alt=""/></p>

<p>Enjoy!</p>

<p>Curtis</p>


			</div>
			<hr/>
		

	</div>
	<script src="/web/20170702094731js_/http://curtisautery.appspot.com/static/jquery/jquery-2.0.3.min.js"></script>
	<script src="/web/20170702094731js_/http://curtisautery.appspot.com/static/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>
<!--
     FILE ARCHIVED ON 09:47:31 Jul 02, 2017 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 17:36:56 Oct 26, 2020.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 637.931
  exclusion.robots: 0.252
  exclusion.robots.policy: 0.242
  RedisCDXSource: 8.509
  esindex: 0.018
  LoadShardBlock: 602.765 (3)
  PetaboxLoader3.datanode: 244.494 (4)
  CDXLines.iter: 22.378 (3)
  PetaboxLoader3.resolve: 94.345 (2)
  load_resource: 139.479
-->